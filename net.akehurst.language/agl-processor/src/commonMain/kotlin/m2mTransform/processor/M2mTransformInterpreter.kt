/*
 * Copyright (C) 2025 Dr. David H. Akehurst (http://dr.david.h.akehurst.net)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *          http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package net.akehurst.language.m2mTransform.processor

import net.akehurst.language.api.processor.EvaluationContext
import net.akehurst.language.base.api.SimpleName
import net.akehurst.language.expressions.api.RootExpression
import net.akehurst.language.expressions.processor.ExpressionsInterpreterOverTypedObject
import net.akehurst.language.expressions.processor.ObjectGraph
import net.akehurst.language.expressions.processor.TypedObject
import net.akehurst.language.issues.api.LanguageProcessorPhase
import net.akehurst.language.issues.ram.IssueHolder
import net.akehurst.language.m2mTransform.api.*
import net.akehurst.language.types.api.PropertyName
import kotlin.collections.component1
import kotlin.collections.component2

data class M2MTransformResult<OT : Any>(
    val issues: IssueHolder,
    val objects: Map<DomainReference, TypedObject<OT>>
)

data class TemplateMatchResult<OT : Any>(
    val isMatch: Boolean,
    val matchedVariables: Map<String, TypedObject<OT>>,
    val issues: IssueHolder,
) {
    companion object {
        fun <OT : Any> EMPTY() = TemplateMatchResult<OT>(true, emptyMap(), IssueHolder(LanguageProcessorPhase.INTERPRET))
    }

    fun merge(other: TemplateMatchResult<OT>): TemplateMatchResult<OT> {
        val issues = IssueHolder(LanguageProcessorPhase.INTERPRET)
        issues.addAll(this.issues)
        issues.addAll(other.issues)
        return TemplateMatchResult(this.isMatch && other.isMatch, this.matchedVariables + other.matchedVariables, issues)
    }
}

class M2mTransformInterpreter<OT : Any>(
    val m2m: M2mTransformDomain,
    val objectGraph: Map<SimpleName, ObjectGraph<OT>>,
    val _issues: IssueHolder = IssueHolder(LanguageProcessorPhase.INTERPRET)
) {

// In commonMain/kotlin/YourPackage/CombinationFinder.kt

// In commonMain/kotlin/YourPackage/CombinationFinder.kt

    companion object {

        data class CoverOption<C, R>(val c: C, val r: R)

        /**
         * Finds all subsets (combinations) R of type R, where R is generated by C elements
         * that collectively cover all elements in List1 (T).
         *
         * @param List1 The elements T that MUST ALL be covered (the requirements).
         * @param List2 The elements C to choose from (the options).
         * @param matches A function returning Pair<Boolean, R> for a match/transformed R element.
         * @return A Set of Lists, representing all valid covering combinations of type R.
         */
        fun <T, C, R> findCoveringSubsets(
            List1: List<T>,
            List2: List<C>,
            matches: (c: C, t: T) -> Pair<Boolean, R>
        ): Set<List<R>> {

            // --- STEP 1: Pre-process Mapping and R-Generation ---

            // T_to_CoverMap: Map<t_element, Set<CoverOption>>
            val tToCoverMap: Map<T, Set<CoverOption<C, R>>> = List1.associateWith { tElement ->
                List2.mapNotNull { cElement ->
                    val (isMatch, rValue) = matches(cElement, tElement)
                    if (isMatch) CoverOption(cElement, rValue) else null
                }.toSet()
            }

            // --- IMPOSSIBLE CHECK ---
            if (tToCoverMap.values.any { it.isEmpty() }) {
                return emptySet()
            }

            // --- STEP 2: Recursive Search for Minimal Covers ---

            val resultsR = mutableSetOf<Set<R>>()

            // Start the recursive search
            searchCovers(
                remainingT = List1.toMutableList(),
                tToCoverMap = tToCoverMap,
                currentCoverC = mutableSetOf(),
                currentCoverR = mutableSetOf(),
                resultsR = resultsR
            )

            // --- STEP 3: Combine Minimal R-Covers with Optional R-Elements (Finalization) ---
            return finalizeRResults(List2, tToCoverMap, resultsR, matches)
        }

        /**
         * Recursive helper function based on the set-covering heuristic.
         */
        private fun <T, C, R> searchCovers(
            remainingT: MutableList<T>,
            tToCoverMap: Map<T, Set<CoverOption<C, R>>>,
            currentCoverC: MutableSet<C>,
            currentCoverR: MutableSet<R>,
            resultsR: MutableSet<Set<R>>
        ) {
            // BASE CASE: All T elements covered.
            if (remainingT.isEmpty()) {
                resultsR.add(currentCoverR.toSet())
                return
            }

            val tToCover = remainingT.removeAt(0)
            val coverOptions = tToCoverMap[tToCover] ?: emptySet()

            for (option in coverOptions) {
                val cElement = option.c
                val rElement = option.r

                // CHOOSE: Only proceed if the C element hasn't been used yet (unique source).
                if (currentCoverC.add(cElement)) {
                    currentCoverR.add(rElement)

                    // PRUNE: Identify and remove other T elements covered by this C element.
                    val newlyCoveredT = remainingT.filter { t ->
                        tToCoverMap[t]?.any { it.c == cElement } == true
                    }.toMutableList()

                    remainingT.removeAll(newlyCoveredT.toSet())

                    // RECURSE
                    searchCovers(remainingT, tToCoverMap, currentCoverC, currentCoverR, resultsR)

                    // UNCHOOSE (Backtrack):
                    remainingT.addAll(newlyCoveredT)
                    currentCoverC.remove(cElement)
                    currentCoverR.remove(rElement)
                }
            }

            remainingT.add(tToCover)
        }

        /**
         * Combines the minimal R-covers with all combinations of "optional" R-elements.
         */
        private fun <T, C, R> finalizeRResults(
            List2: List<C>,
            tToCoverMap: Map<T, Set<CoverOption<C, R>>>,
            minimalRCovers: Set<Set<R>>,
            matches: (c: C, t: T) -> Pair<Boolean, R>
        ): Set<List<R>> {
            if (minimalRCovers.isEmpty()) return emptySet()

            // 1. Identify "Optional" R-elements (those not required for T coverage)
            val requiredCElements = tToCoverMap.values.flatten().map { it.c }.toSet()
            val cOptional = List2.toSet() - requiredCElements

            // 2. Map optional C elements to their R values.
            val optionalROptions = cOptional.mapNotNull { c ->
                // We need a T element to call 'matches'. Since the C element is optional,
                // its generated R value should be independent of the specific T. We use the first T.
                // This assumes 'matches' for an optional C element consistently returns the same R.
                tToCoverMap.keys.firstOrNull()?.let { t ->
                    val (isMatch, r) = matches(c, t)
                    if (isMatch) r else null
                }
            }.toSet()

            // 3. Generate the power set of optional R elements.
            val optionalRSubsets = powerSet(optionalROptions.toList())

            // 4. Combine every minimal R cover with every optional R subset.
            val allValidCombinations = mutableSetOf<List<R>>()
            for (minRCover in minimalRCovers) {
                for (optionalRSubset in optionalRSubsets) {
                    allValidCombinations.add((minRCover + optionalRSubset).toList())
                }
            }
            return allValidCombinations
        }

        /**
         * Helper to recursively generate the power set of R elements.
         */
        private fun <R> powerSet(list: List<R>): Set<Set<R>> {
            if (list.isEmpty()) return setOf(emptySet())
            val head = list.first()
            val tail = list.drop(1)
            val subsetsOfTail = powerSet(tail)
            val subsetsWithHead = subsetsOfTail.map { subset -> subset + head }.toSet()
            return subsetsOfTail + subsetsWithHead
        }
    }

    fun transform(targetDomainRef: DomainReference, root: Map<DomainReference, TypedObject<OT>>): M2MTransformResult<OT> {
        val pair = m2m.allTransformRuleSet.firstNotNullOfOrNull {
            val dp = it.domainParameters // domainRef -> Domain-Name
            val tr = it.topRule.firstOrNull { tr ->
                val srcDomainRefs = tr.domainSignature.filterKeys { k -> k != targetDomainRef }
                srcDomainRefs.keys == root.keys
                        && root.entries.all { (k, v) ->
                    tr.domainSignature[k]?.let { di ->
                        di.variable.type.let { dt ->
                            v.type.conformsTo(dt)
                        }
                    } ?: false
                }
            }
            Pair(dp, tr)
        }
        val topRule = pair?.second
        val result = when (topRule) {
            null -> {
                _issues.error(null, "No conforming top rule found for target domain '${targetDomainRef.value}'")
                emptyMap<DomainReference, TypedObject<OT>>()
            }

            is M2mRelation -> {
                val domainParameters = pair.first
                executeRelation(topRule, domainParameters, targetDomainRef, root)
            }

            is M2mMapping -> {
                val domainParameters = pair.first
                executeMapping(topRule, domainParameters, targetDomainRef, root)
            }

            else -> error("")
        }

        return M2MTransformResult<OT>(_issues, result)
    }

    private fun executeMapping(
        rule: M2mMapping,
        domainParameters: Map<DomainReference, SimpleName>,
        targetDomainRef: DomainReference,
        source: Map<DomainReference, TypedObject<OT>>
    ): Map<DomainReference, TypedObject<OT>> {
        val (isMatch, variables, issues) = matchSourceVariables(domainParameters, rule, targetDomainRef, source)
        return when {
            isMatch -> {
                val expression = rule.expression[targetDomainRef]
                when (expression) {
                    null -> {
                        _issues.error(null, "No expression found for target domain ref '$targetDomainRef'")
                        emptyMap()
                    }

                    else -> {
                        val dtn = domainParameters[targetDomainRef] ?: error("DomainParameter not found for target domain ref '$targetDomainRef'")
                        val tgtOg = objectGraph[dtn] ?: error("ObjectGraph not found for domain '$dtn'")
                        val exprInterp = ExpressionsInterpreterOverTypedObject<OT>(tgtOg, _issues)
                        val evc = EvaluationContext.of(variables)
                        val target = exprInterp.evaluateExpression(evc, expression)
                        val result = mutableMapOf<DomainReference, TypedObject<OT>>()
                        result[targetDomainRef] = target
                        result
                    }
                }
            }

            else -> emptyMap()
        }
    }

    private fun executeRelation(
        rule: M2mRelation,
        domainParameters: Map<DomainReference, SimpleName>,
        targetDomainRef: DomainReference,
        source: Map<DomainReference, TypedObject<OT>>
    ): Map<DomainReference, TypedObject<OT>> {
        val result = mutableMapOf<DomainReference, TypedObject<OT>>()
        val (isMatch, variables, issues) = matchSourceVariables(domainParameters, rule, targetDomainRef, source)

        if (isMatch) {
            val dtn = domainParameters[targetDomainRef] ?: error("DomainParameter not found for domain '$targetDomainRef'")
            val tgtOg = objectGraph[dtn] ?: error("ObjectGraph not found for domain '$dtn'")
            val objPat = rule.objectTemplate[targetDomainRef] ?: error("No object pattern found for domain '$targetDomainRef'")
            val obj = createFromRhs(variables, objPat, tgtOg)
            result[targetDomainRef] = obj

        } else {
            // no match, do nothing
        }
        return result
    }

    private fun matchSourceVariables(
        domainParameters: Map<DomainReference, SimpleName>,
        rule: M2mTangibleRule,
        targetDomainRef: DomainReference,
        source: Map<DomainReference, TypedObject<OT>>
    ): TemplateMatchResult<OT> {
        val srcDomainRefs = rule.domainSignature.filterKeys { k -> k != targetDomainRef }
        val results = srcDomainRefs.map { (srcDomainRef, srcDomainItem) ->
            val srcDtn = domainParameters[srcDomainRef]
            val srcOg = objectGraph[srcDtn] ?: error("ObjectGraph not found for domain '$srcDomainRef'")
            val srcObjPat = rule.objectTemplate[srcDomainRef] ?: error("No object pattern found for domain '$srcDomainRef'")
            // match variables from source domain
            val src = source[srcDomainRef] ?: error("No source object found for domain '$srcDomainRef'")
            matchVariablesFromRhs(emptyMap(), srcOg, src, srcObjPat)
        }
        return results.fold(TemplateMatchResult.EMPTY<OT>()) { acc, it -> acc.merge(it) }
    }

    fun matchVariablesFromRhs(variables: Map<String, TypedObject<OT>>, srcObjectGraph: ObjectGraph<OT>, src: TypedObject<OT>, rhs: PropertyTemplateRhs): TemplateMatchResult<OT> =
        when (rhs) {
            is PropertyTemplateExpression -> matchVariablesFromPropertyTemplateExpression(variables, srcObjectGraph, src, rhs)
            is ObjectTemplate -> matchVariablesFromObjectTemplate(variables, rhs, srcObjectGraph, src)
            is CollectionTemplate -> matchVariablesFromCollectionTemplate(variables, rhs, srcObjectGraph, src)
            else -> error("Unknown rhs type ${rhs::class}")
        }

    /**
     * always returns isMatch==true
     */
    fun matchVariablesFromPropertyTemplateExpression(
        variables: Map<String, TypedObject<OT>>,
        srcObjectGraph: ObjectGraph<OT>,
        lhs: TypedObject<OT>,
        rhs: PropertyTemplateExpression
    ): TemplateMatchResult<OT> {
        // either :
        // 1) rhs is a free-variable with no value set, in which case set it to the lhs
        // 2) rhs is an expression with a value that matches the lhs
        val expr = rhs.expression
        return when {
            expr is RootExpression && variables.contains(expr.name).not() -> {
                val issues = IssueHolder(LanguageProcessorPhase.INTERPRET)
                TemplateMatchResult(true, mapOf(expr.name to lhs), issues)
            }

            else -> {
                val issues = IssueHolder(LanguageProcessorPhase.INTERPRET)
                val exprInterp = ExpressionsInterpreterOverTypedObject<OT>(srcObjectGraph, issues)
                val evc = EvaluationContext.of(variables)
                val value = exprInterp.evaluateExpression(evc, expr)
                val isMatch = srcObjectGraph.equalTo(lhs, value)
                TemplateMatchResult(isMatch, emptyMap(), issues)
            }
        }
    }

    fun matchVariablesFromObjectTemplate(
        variables: Map<String, TypedObject<OT>>,
        objectTemplate: ObjectTemplate,
        srcObjectGraph: ObjectGraph<OT>,
        src: TypedObject<OT>
    ): TemplateMatchResult<OT> {
        val propTemplateMatches = objectTemplate.propertyTemplate.map { (k, v) ->
            val rhsPat = v.rhs
            val lhs = srcObjectGraph.getProperty(src, k.value)
            matchVariablesFromRhs(variables, srcObjectGraph, lhs, rhsPat)
        }
        val result = propTemplateMatches.fold(TemplateMatchResult.EMPTY<OT>()) { acc, it -> acc.merge(it) }
//        when {
//            result.isMatch -> {
//                val sv = srcObjectGraph.getProperty(src, k.value)
//                srcObjectGraph.equalTo(sv, res.value)
//            }
//
//            srcObjectGraph.isNothing(res.value) -> {
//                // rhs variable not set, so set it
//                val varName = when {
//                    rhsPat is PropertyTemplateExpression -> when {
//                        rhsPat.expression is RootExpression -> {
//                            val n = (rhsPat.expression as RootExpression).name
//                            SimpleName(n)
//                        }
//
//                        else -> error("rhs expression is not a pivot variable name, cannot set it")
//                    }
//
//                    else -> error("rhs is not a PropertyPatternExpression, cannot set it")
//                }
//                val value = srcObjectGraph.getProperty(src, k.value)
//                variables[varName.value] = value
//                true
//            }
//
//            else -> {
//                false
//            }
//        }

        // if the pattern has a name, assign it
        val vars = objectTemplate.identifier?.let { result.matchedVariables + Pair(it.value, src) } ?: result.matchedVariables
        return TemplateMatchResult(result.isMatch, vars, result.issues)
    }

    fun matchVariablesFromCollectionTemplate(
        variables: Map<String, TypedObject<OT>>,
        collectionTemplate: CollectionTemplate,
        srcObjectGraph: ObjectGraph<OT>,
        src: TypedObject<OT>
    ): TemplateMatchResult<OT> {
        val issues = IssueHolder(LanguageProcessorPhase.INTERPRET)
        val result = when {
            src.type.isCollection -> {
                val elements = mutableListOf<TypedObject<OT>>()
                srcObjectGraph.forEachIndexed(src) { idx, el -> elements.add(el) }
                val results = findCoveringSubsets(
                    collectionTemplate.elements,
                    elements
                ) { tp, el ->
                    val mr = matchVariablesFromRhs(variables, srcObjectGraph, tp, el)
                    Pair(mr.isMatch, mr)
                }

                results.firstOrNull() ?: emptyList() //TODO: all matches
            }

            else -> error("src is not a collection")
        }
        return result.fold(TemplateMatchResult.EMPTY<OT>()) { acc, it -> acc.merge(it) }
    }

    fun createFromRhs(variables: Map<String, TypedObject<OT>>, rhs: PropertyTemplateRhs, tgtObjectGraph: ObjectGraph<OT>): TypedObject<OT> = when (rhs) {
        is PropertyTemplateExpression -> createFromPropertyPatternExpression(variables, rhs, tgtObjectGraph)
        is ObjectTemplate -> createFromObjectPattern(variables, rhs, tgtObjectGraph)
        else -> error("Unknown rhs type ${rhs::class}")
    }

    /**
     * returns value of expression evaluated in context of provided variables
     */
    fun createFromPropertyPatternExpression(variables: Map<String, TypedObject<OT>>, ppe: PropertyTemplateExpression, tgtObjectGraph: ObjectGraph<OT>): TypedObject<OT> {
        val expr = ppe.expression
        val exprInterp = ExpressionsInterpreterOverTypedObject<OT>(tgtObjectGraph, _issues)
        val evc = EvaluationContext.of(variables)
        val value = exprInterp.evaluateExpression(evc, expr)
        return value
    }

    fun createFromObjectPattern(variables: Map<String, TypedObject<OT>>, objectTemplate: ObjectTemplate, tgtObjectGraph: ObjectGraph<OT>): TypedObject<OT> {
        val propValues = mutableMapOf<String, TypedObject<OT>>()
        objectTemplate.propertyTemplate.forEach { (k, v) ->
            val value = createFromRhs(variables, v.rhs, tgtObjectGraph)
            propValues[k.value] = value
        }
        objectTemplate.resolveType(tgtObjectGraph.typesDomain)
        val obj = tgtObjectGraph.createStructureValue(objectTemplate.type.qualifiedTypeName, propValues)
        propValues.forEach { (k, v) ->
            val pn = PropertyName(k)
            if (true == objectTemplate.type.allResolvedProperty[pn]?.isReadWrite) {
                tgtObjectGraph.setProperty(obj, k, v)
            }
        }
        return obj
    }


}