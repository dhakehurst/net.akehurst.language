/*
 * Copyright (C) 2025 Dr. David H. Akehurst (http://dr.david.h.akehurst.net)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *          http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package net.akehurst.language.m2mTransform.processor

import net.akehurst.language.api.processor.EvaluationContext
import net.akehurst.language.base.api.SimpleName
import net.akehurst.language.expressions.api.RootExpression
import net.akehurst.language.expressions.processor.ExpressionsInterpreterOverTypedObject
import net.akehurst.language.expressions.processor.ObjectGraph
import net.akehurst.language.expressions.processor.TypedObject
import net.akehurst.language.issues.api.LanguageProcessorPhase
import net.akehurst.language.issues.ram.IssueHolder
import net.akehurst.language.m2mTransform.api.*
import net.akehurst.language.m2mTransform.processor.TemplateMatchResult.Companion.merge
import net.akehurst.language.types.api.PropertyName

data class M2MTransformResult<OT : Any>(
    val issues: IssueHolder,
    val objects: List<TypedObject<OT>>
)

data class TemplateMatchAlternatives<OT : Any>(
    val alternatives: List<TemplateMatchResult<OT>>
)

data class TemplateMatchResult<OT : Any>(
    val isMatch: Boolean,
    val matchedVariables: Map<String, TypedObject<OT>>
) {
    companion object {
        fun <OT : Any> EMPTY() = TemplateMatchResult<OT>(true, emptyMap())
        fun <OT : Any> List<TemplateMatchResult<OT>>.merge() = this.fold(TemplateMatchResult.EMPTY<OT>()) { acc, it -> acc.merge(it) }
    }

    fun merge(other: TemplateMatchResult<OT>): TemplateMatchResult<OT> {
        return TemplateMatchResult(this.isMatch && other.isMatch, this.matchedVariables + other.matchedVariables)
    }
}

class M2mTransformInterpreter<OT : Any>(
    val m2m: M2mTransformDomain,
    val domainObjectGraph: Map<SimpleName, ObjectGraph<OT>>,
    val _issues: IssueHolder = IssueHolder(LanguageProcessorPhase.INTERPRET)
) {

    companion object {

        data class CoverOption<C, R>(val c: C, val r: R)

        /**
         * Finds all subsets (combinations) R of type R, where R is generated by C elements
         * that collectively cover all elements in List1 (T).
         *
         * @param List1 The elements T that MUST ALL be covered (the requirements).
         * @param List2 The elements C to choose from (the options).
         * @param matches A function returning Pair<Boolean, R> for a match/transformed R element.
         * @return A Set of Lists, representing all valid covering combinations of type R.
         */
        fun <T, C, R> findCoveringSubsets(
            List1: List<T>,
            List2: List<C>,
            matches: (c: C, t: T) -> Pair<Boolean, R>
        ): Set<List<R>> {

            // --- STEP 1: Pre-process Mapping and R-Generation ---

            // T_to_CoverMap: Map<t_element, Set<CoverOption>>
            val tToCoverMap: Map<T, Set<CoverOption<C, R>>> = List1.associateWith { tElement ->
                List2.mapNotNull { cElement ->
                    val (isMatch, rValue) = matches(cElement, tElement)
                    if (isMatch) CoverOption(cElement, rValue) else null
                }.toSet()
            }

            // --- IMPOSSIBLE CHECK ---
            if (tToCoverMap.values.any { it.isEmpty() }) {
                return emptySet()
            }

            // --- STEP 2: Recursive Search for Minimal Covers ---

            val resultsR = mutableSetOf<Set<R>>()

            // Start the recursive search
            searchCovers(
                remainingT = List1.toMutableList(),
                tToCoverMap = tToCoverMap,
                currentCoverC = mutableSetOf(),
                currentCoverR = mutableSetOf(),
                resultsR = resultsR
            )

            // --- STEP 3: Combine Minimal R-Covers with Optional R-Elements (Finalization) ---
            return finalizeRResults(List2, tToCoverMap, resultsR, matches)
        }

        /**
         * Recursive helper function based on the set-covering heuristic.
         */
        private fun <T, C, R> searchCovers(
            remainingT: MutableList<T>,
            tToCoverMap: Map<T, Set<CoverOption<C, R>>>,
            currentCoverC: MutableSet<C>,
            currentCoverR: MutableSet<R>,
            resultsR: MutableSet<Set<R>>
        ) {
            // BASE CASE: All T elements covered.
            if (remainingT.isEmpty()) {
                resultsR.add(currentCoverR.toSet())
                return
            }

            val tToCover = remainingT.removeAt(0)
            val coverOptions = tToCoverMap[tToCover] ?: emptySet()

            for (option in coverOptions) {
                val cElement = option.c
                val rElement = option.r

                // CHOOSE: Only proceed if the C element hasn't been used yet (unique source).
                if (currentCoverC.add(cElement)) {
                    currentCoverR.add(rElement)

                    // PRUNE: Identify and remove other T elements covered by this C element.
                    val newlyCoveredT = remainingT.filter { t ->
                        tToCoverMap[t]?.any { it.c == cElement } == true
                    }.toMutableList()

                    remainingT.removeAll(newlyCoveredT.toSet())

                    // RECURSE
                    searchCovers(remainingT, tToCoverMap, currentCoverC, currentCoverR, resultsR)

                    // UNCHOOSE (Backtrack):
                    remainingT.addAll(newlyCoveredT)
                    currentCoverC.remove(cElement)
                    currentCoverR.remove(rElement)
                }
            }

            remainingT.add(tToCover)
        }

        /**
         * Combines the minimal R-covers with all combinations of "optional" R-elements.
         */
        private fun <T, C, R> finalizeRResults(
            List2: List<C>,
            tToCoverMap: Map<T, Set<CoverOption<C, R>>>,
            minimalRCovers: Set<Set<R>>,
            matches: (c: C, t: T) -> Pair<Boolean, R>
        ): Set<List<R>> {
            if (minimalRCovers.isEmpty()) return emptySet()

            // 1. Identify "Optional" R-elements (those not required for T coverage)
            val requiredCElements = tToCoverMap.values.flatten().map { it.c }.toSet()
            val cOptional = List2.toSet() - requiredCElements

            // 2. Map optional C elements to their R values.
            val optionalROptions = cOptional.mapNotNull { c ->
                // We need a T element to call 'matches'. Since the C element is optional,
                // its generated R value should be independent of the specific T. We use the first T.
                // This assumes 'matches' for an optional C element consistently returns the same R.
                tToCoverMap.keys.firstOrNull()?.let { t ->
                    val (isMatch, r) = matches(c, t)
                    if (isMatch) r else null
                }
            }.toSet()

            // 3. Generate the power set of optional R elements.
            val optionalRSubsets = powerSet(optionalROptions.toList())

            // 4. Combine every minimal R cover with every optional R subset.
            val allValidCombinations = mutableSetOf<List<R>>()
            for (minRCover in minimalRCovers) {
                for (optionalRSubset in optionalRSubsets) {
                    allValidCombinations.add((minRCover + optionalRSubset).toList())
                }
            }
            return allValidCombinations
        }

        /**
         * Helper to recursively generate the power set of R elements.
         */
        private fun <R> powerSet(list: List<R>): Set<Set<R>> {
            if (list.isEmpty()) return setOf(emptySet())
            val head = list.first()
            val tail = list.drop(1)
            val subsetsOfTail = powerSet(tail)
            val subsetsWithHead = subsetsOfTail.map { subset -> subset + head }.toSet()
            return subsetsOfTail + subsetsWithHead
        }

        fun <OT : Any> List<TemplateMatchAlternatives<OT>>.cartesianProduct(): TemplateMatchAlternatives<OT> {
            val lists = this.map { it.alternatives }
            val cp = lists.cartesianProduct()
            val alts = cp.map { it.merge() }
            return TemplateMatchAlternatives(alts)
        }

        /**
         * Calculates the Cartesian Product of a list of lists using an iterative approach.
         * This implementation is robust against StackOverflowError for a very large number of lists.
         *
         * @param lists The top list (T) where each element is a list (L1, L2, ...).
         * @return A Set of Lists, where each result list contains exactly one element
         * from each of the input lists.
         */
        fun <E> List<List<E>>.cartesianProduct(): Set<List<E>> {

            // Edge Case: If the input is empty or contains an empty list, the product is empty.
            if (this.isEmpty() || this.any { it.isEmpty() }) {
                return emptySet()
            }

            // Start with a set containing a single empty list.
            // This represents the "combination" of the lists processed so far (which is none).
            var result: Set<List<E>> = setOf(emptyList())

            // Iterate through each list in the input (L1, L2, L3, ...)
            for (currentList in this) {

                // Create a temporary set to store the new, extended combinations
                val nextResult = mutableSetOf<List<E>>()

                // Inner Loop 1: Iterate over the existing partial combinations
                for (combination in result) {

                    // Inner Loop 2: Iterate over the elements in the current input list
                    for (element in currentList) {

                        // Create a new, longer combination by appending the element
                        // to the existing partial combination.
                        nextResult.add(combination + element)
                    }
                }

                // Update the main result set to the newly generated combinations
                result = nextResult
            }

            return result
        }
    }

    /**
     * @param targetDomainRef reference to the domain that is the target of the transformation
     * @param domainGraphs the objects for each source domain, keyed by the domain reference
     */
    fun transform(targetTransform: M2mTransformRuleSet, targetDomainRef: DomainReference, domainGraphs: Map<DomainReference, List<TypedObject<OT>>>): M2MTransformResult<OT> {
        val objectGraphHandler = targetTransform.domainParameters.entries.associate { (k, v) ->
            Pair(k, domainObjectGraph[v] ?: error("Domain ObjectGraph not found for domain $k"))
        }

        val result = when {
            targetTransform.topRule.isEmpty() -> {
                _issues.error(null, "No conforming top rule found for target domain '${targetDomainRef.value}'")
                emptyList()
            }

            else -> {
                targetTransform.topRule.map { topRule ->
                    executeRule(topRule, targetDomainRef, domainGraphs, objectGraphHandler)
                }
            }
        }
        return M2MTransformResult<OT>(_issues, result)
    }

    private fun executeRule(
        rule: M2mTransformRule,
        targetDomainRef: DomainReference,
        source: Map<DomainReference, List<TypedObject<OT>>>,
        sourceObjectGraph: Map<DomainReference, ObjectGraph<OT>>,
    ) = when (rule) {
        is M2mTransformAbstractRule -> executeAbstract(rule, targetDomainRef, source, sourceObjectGraph)
        is M2MTransformRelation -> executeRelation(rule, targetDomainRef, source, sourceObjectGraph)
        is M2MTransformMapping -> executeMapping(rule, targetDomainRef, source, sourceObjectGraph)
        else -> error("Unknown rule type ${rule::class}")
    }

    private fun executeAbstract(
        rule: M2mTransformAbstractRule,
        targetDomainRef: DomainReference,
        source: Map<DomainReference, List<TypedObject<OT>>>,
        objectGraph: Map<DomainReference, ObjectGraph<OT>>,
    ): TypedObject<OT> {
        TODO()
    }

    private fun executeMapping(
        rule: M2MTransformMapping,
        targetDomainRef: DomainReference,
        source: Map<DomainReference, List<TypedObject<OT>>>,
        objectGraph: Map<DomainReference, ObjectGraph<OT>>,
    ): TypedObject<OT> {
        val tgtOg = objectGraph[targetDomainRef] ?: error("ObjectGraph not found for domain '$targetDomainRef'")
        val altsPerSrcCombination = matchSourceVariables(rule, targetDomainRef, source, objectGraph)
        return when {
            altsPerSrcCombination.isEmpty() -> {
                _issues.warn(null, "No matches found in source domains.")
                tgtOg.nothing()
            }

            1 < altsPerSrcCombination.size -> {
                _issues.error(null, "Too many alterntive combinations of source domains matched.")
                tgtOg.nothing()
            }

            else -> {
                val alt = altsPerSrcCombination.first()
                when {
                    alt.alternatives.isEmpty() -> error("Should not happen as this is indicate no match")
                    1 < alt.alternatives.size -> error("Cannot execute mapping if multiple alternative top mapping matches for a single root object")
                    else -> {
                        val expression = rule.expression[targetDomainRef]
                        when (expression) {
                            null -> {
                                _issues.error(null, "No expression found for target domain ref '$targetDomainRef'")
                                tgtOg.nothing()
                            }

                            else -> {
                                val mr = alt.alternatives.first()
                                val exprInterp = ExpressionsInterpreterOverTypedObject<OT>(tgtOg, _issues)
                                val evc = EvaluationContext.of(mr.matchedVariables)
                                exprInterp.evaluateExpression(evc, expression)
                            }
                        }
                    }
                }
            }
        }
    }

    private fun executeRelation(
        rule: M2MTransformRelation,
        targetDomainRef: DomainReference,
        source: Map<DomainReference, List<TypedObject<OT>>>,
        objectGraph: Map<DomainReference, ObjectGraph<OT>>,
    ): TypedObject<OT> {
        val tgtOg = objectGraph[targetDomainRef] ?: error("ObjectGraph not found for domain '$targetDomainRef'")
        val altsPerSrcCombination = matchSourceVariables(rule, targetDomainRef, source, objectGraph)
        return when {
            altsPerSrcCombination.isEmpty() -> {
                _issues.warn(null, "No matches found in source domains.")
                tgtOg.nothing()
            }

            1 < altsPerSrcCombination.size -> {
                _issues.error(null, "Too many alterntive combinations of source domains matched.")
                tgtOg.nothing()
            }

            else -> {
                val alt = altsPerSrcCombination.first()
                when {
                    alt.alternatives.isEmpty() -> error("Should not happen as this is indicate no match")
                    1 < alt.alternatives.size -> error("Cannot execute mapping if multiple alternative top mapping matches for a single root object")
                    else -> {
                        val mr = alt.alternatives.first()
                        val objPat = rule.objectTemplate[targetDomainRef] ?: error("No object pattern found for domain '$targetDomainRef'")
                        createFromRhs(mr.matchedVariables, objPat, tgtOg)
                    }
                }
            }
        }
    }

    private fun matchSourceVariables(
        rule: M2mTransformTangibleRule,
        targetDomainRef: DomainReference,
        source: Map<DomainReference, List<TypedObject<OT>>>,
        objectGraph: Map<DomainReference, ObjectGraph<OT>>,
    ): List<TemplateMatchAlternatives<OT>> {
        val srcDomainRefs = rule.domainSignature.filterKeys { k -> k != targetDomainRef }
        val results = srcDomainRefs.flatMap { (srcDomainRef, srcDomainItem) ->
            val srcOg = objectGraph[srcDomainRef] ?: error("ObjectGraph not found for domain '$srcDomainRef'")
            val srcObjPat = rule.objectTemplate[srcDomainRef] ?: error("No object pattern found for domain '$srcDomainRef'")
            // match variables from source domain
            val srcList = source[srcDomainRef] ?: error("No source object found for domain '$srcDomainRef'")
            srcList.map { src ->
                matchVariablesFromRhs(emptyMap(), srcOg, src, srcObjPat)
            }
        }
        // results contains, for each source domain, a list of alternative MatchResults
        return results
    }

    fun matchVariablesFromRhs(
        variables: Map<String, TypedObject<OT>>,
        srcObjectGraph: ObjectGraph<OT>,
        src: TypedObject<OT>,
        rhs: PropertyTemplateRhs
    ): TemplateMatchAlternatives<OT> =
        when (rhs) {
            is PropertyTemplateExpression -> {
                val mr = matchVariablesFromPropertyTemplateExpression(variables, srcObjectGraph, src, rhs)
                // only keep the result if it is a match
                mr.takeIf { it.isMatch }?.let { TemplateMatchAlternatives(listOf(it)) } ?: TemplateMatchAlternatives(emptyList())
            }

            is ObjectTemplate -> matchVariablesFromObjectTemplate(variables, rhs, srcObjectGraph, src)
            is CollectionTemplate -> matchVariablesFromCollectionTemplate(variables, rhs, srcObjectGraph, src)
            else -> error("Unknown rhs type ${rhs::class}")
        }

    /**
     * always returns isMatch==true
     */
    fun matchVariablesFromPropertyTemplateExpression(
        variables: Map<String, TypedObject<OT>>,
        srcObjectGraph: ObjectGraph<OT>,
        lhs: TypedObject<OT>,
        rhs: PropertyTemplateExpression
    ): TemplateMatchResult<OT> {
        // either :
        // 1) rhs is a free-variable with no value set, in which case set it to the lhs
        // 2) rhs is an expression with a value that matches the lhs
        val expr = rhs.expression
        return when {
            expr is RootExpression && variables.contains(expr.name).not() -> {
                TemplateMatchResult(true, mapOf(expr.name to lhs))
            }

            else -> {
                val exprInterp = ExpressionsInterpreterOverTypedObject<OT>(srcObjectGraph, _issues)
                val evc = EvaluationContext.of(variables)
                val value = exprInterp.evaluateExpression(evc, expr)
                val isMatch = srcObjectGraph.equalTo(lhs, value)
                TemplateMatchResult(isMatch, emptyMap())
            }
        }
    }

    fun matchVariablesFromObjectTemplate(
        variables: Map<String, TypedObject<OT>>,
        objectTemplate: ObjectTemplate,
        srcObjectGraph: ObjectGraph<OT>,
        src: TypedObject<OT>
    ): TemplateMatchAlternatives<OT> {
        val propTemplateMatches = objectTemplate.propertyTemplate.map { (k, v) ->
            val rhsPat = v.rhs
            val lhs = srcObjectGraph.getProperty(src, k.value)
            matchVariablesFromRhs(variables, srcObjectGraph, lhs, rhsPat)
        }
        val result = propTemplateMatches.map { it.alternatives }.cartesianProduct()

        // if the pattern has a name, assign it
        val selfNameValue = objectTemplate.identifier?.let { Pair(it.value, src) }
        val alts = result.map { l -> l.merge() }.filter { it.isMatch }
        return TemplateMatchAlternatives(alts)
    }

    fun matchVariablesFromCollectionTemplate(
        variables: Map<String, TypedObject<OT>>,
        collectionTemplate: CollectionTemplate,
        srcObjectGraph: ObjectGraph<OT>,
        src: TypedObject<OT>
    ): TemplateMatchAlternatives<OT> {
        val result = when {
            src.type.isCollection -> {
                val elements = mutableListOf<TypedObject<OT>>()
                srcObjectGraph.forEachIndexed(src) { idx, el -> elements.add(el) }
                val options = findCoveringSubsets(
                    collectionTemplate.elements,
                    elements
                ) { tp, el ->
                    val mr = matchVariablesFromRhs(variables, srcObjectGraph, tp, el)
                    Pair(mr.alternatives.isNotEmpty(), mr)
                }
                options.map { }
            }

            else -> error("src is not a collection")
        }
        TODO()
        //return TemplateMatchAlternatives(result)
    }

    fun createFromRhs(variables: Map<String, TypedObject<OT>>, rhs: PropertyTemplateRhs, tgtObjectGraph: ObjectGraph<OT>): TypedObject<OT> = when (rhs) {
        is PropertyTemplateExpression -> createFromPropertyPatternExpression(variables, rhs, tgtObjectGraph)
        is ObjectTemplate -> createFromObjectPattern(variables, rhs, tgtObjectGraph)
        else -> error("Unknown rhs type ${rhs::class}")
    }

    /**
     * returns value of expression evaluated in context of provided variables
     */
    fun createFromPropertyPatternExpression(variables: Map<String, TypedObject<OT>>, ppe: PropertyTemplateExpression, tgtObjectGraph: ObjectGraph<OT>): TypedObject<OT> {
        val expr = ppe.expression
        val exprInterp = ExpressionsInterpreterOverTypedObject<OT>(tgtObjectGraph, _issues)
        val evc = EvaluationContext.of(variables)
        val value = exprInterp.evaluateExpression(evc, expr)
        return value
    }

    fun createFromObjectPattern(variables: Map<String, TypedObject<OT>>, objectTemplate: ObjectTemplate, tgtObjectGraph: ObjectGraph<OT>): TypedObject<OT> {
        val propValues = mutableMapOf<String, TypedObject<OT>>()
        objectTemplate.propertyTemplate.forEach { (k, v) ->
            val value = createFromRhs(variables, v.rhs, tgtObjectGraph)
            propValues[k.value] = value
        }
        objectTemplate.resolveType(tgtObjectGraph.typesDomain)
        val obj = tgtObjectGraph.createStructureValue(objectTemplate.type.qualifiedTypeName, propValues)
        propValues.forEach { (k, v) ->
            val pn = PropertyName(k)
            if (true == objectTemplate.type.allResolvedProperty[pn]?.isReadWrite) {
                tgtObjectGraph.setProperty(obj, k, v)
            }
        }
        return obj
    }


}